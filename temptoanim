#!/bin/bash
# $1 is silentcast# (i.e. castnum)
# $2 is fps
# $3 is working directory (working_dir) and is optional - defaults to ./

# Usage info
show_help() {
cat << EOF
temptoanim converts temp.mkv to anim.gif

Usage: temptoanim silentcast# fps [working_dir]

    silentcast#     must be 0, 1, or 2

	0: tries to convert ./temp.mkv (if working_dir is also 
	   specified, it will be ignored)
	1: tries to convert working_dir/silentcast/temp.mkv
	2: tries to convert working_dir/silentcast/silentcast/temp.mkv

    fps             is an integer and must match the frames per second used to
	            create temp.mkv. temptoanim doesn't verify the actual fps 
	            in temp.mkv.
	
    Both silentcast# and fps are required and must appear in the correct
    order.

    working_dir     must be the last arg, defaults to ~/ and is where 
                    temptoanim will expect to find the silentcast or 
		    silentcast/silentcast directory


There are some dialogues that come up, and it's important to read
and understand them. View /usr/share/doc/silentcast/README.md with
a markdown viewer and get an animated gif demo made with silentcast,
as well as a step by step guide and a list of tips.
EOF
}

if ! [[ "$1" =~ ^[0-2]$ ]] || ! [[ "$2" =~ ^[0-9]+$ ]]
then
	show_help
	exit 0
fi

castnum=""
if (($1 != 0))
then 
	castnum=$1
fi

cut=0
total_cut=0
group=0
count=0

if [ "$3" != "" ] 
then
	working_dir=$3
else
	working_dir=.
fi

if ! [ -d $working_dir/ ]
then
	echo "$working_dir is not an existing directory, so the silentcast directory can't be there" \
	| yad --text-info --wrap --on-top --center --window-icon="$doc_dir/record.png" --title="Error" --text="<b>SILENTCAST ? </b>"
	exit -1
fi
if (($1 == 1)); then cd $working_dir/silentcast
elif (($1 == 2)); then cd $working_dir/silentcast/silentcast
fi

if ! [ -f temp.mkv ]
then
	echo "temp.mkv not found, so can't convert it to anim.gif" \
	| yad --text-info --wrap --on-top --center --window-icon="$doc_dir/record$castnum".png --title="Error" --text="<b>SILENTCAST $1 </b>"
	exit -1
fi

if [ "$XDG_CURRENT_DESKTOP" = "GNOME"  ] 
then
	nautilus ./ & file_browserPID=$! # for some reason xdg-open doesn't work inside this script in Gnome
else
	xdg-open ./ 
fi
find -maxdepth 1 -name 'anim.gif' -delete
find -maxdepth 1 -regex '\.\/ew-[0-9][0-9][0-9]\.png' -delete

ffmpeg -i temp.mkv -r $2 -an ew-%03d.png \
	| yad --progress --on-top --center --window-icon="$doc_dir/record$castnum".png --text="<b>SILENTCAST $1 </b> \n\
Creating images from temp.mkv" --pulsate --auto-close

while ! [ -f anim.gif ]
do
    xdotool key 'F5' # in testing, Dolphin used by KDE needs this sometimes
    cut=`yad --entry --on-top --center --window-icon="$doc_dir/record$castnum".png \
        --title="Prepare images before converting to Anim.gif" \
        --text="<b>SILENTCAST $1 </b> \n\
Manually delete or otherwise manipulate the images and click OK,\n\
Or \n\
Enter any positive integer less than the total number of images. It works like this:\n\
0 do nothing\n\
1 delete every other\n\
2 delete 2 out of every 3\n\
3 delete 3 out of every 4 ..."\
        --entry-text="0"`
    (($? != 0)) && exit 1 #Cancel was clicked

    let group=$cut+1
    let total_cut=$total_cut+$cut
    if (($group > 1))
    then
    	count=0
    	for f in ew*png
    	do
    		    let count++
		    if (($count % $group != 1))
    		    then
    			    rm $f
    		    fi
    	done
    fi
    convert -adjoin -delay "$((total_cut + 1))"x"$2" -layers optimize *png anim.gif | \
	    yad --progress --on-top --center --title="convert" --window-icon="$doc_dir/record$castnum".png --text="<b>SILENTCAST $1 </b> \n\
	    Replacing images with anim.gif... (clicking Close below doesn't stop convert, so don't)" --pulsate --auto-close
    if ! [ -f anim.gif ]
    then 
	echo "Too many images for the available memory - convert crashed. Try closing other applications, creating a swap file, or removing unecessary images." |\
    	  yad --text-info --wrap --on-top --center --window-icon="$doc_dir/record$castnum".png --title="Error" --text="<b>SILENTCAST $1 </b>"
	(($? != 0)) && exit 1 #Cancel was clicked
    else
    	  rm ew*png
    fi
done

xdotool key 'F5' # in testing, Dolphin used by KDE needs this sometimes
if [ $mp4 = FALSE ] && [ $webm = FALSE ] 
then 
	exit 0
else
	pkill $file_browserPID
	wmctrl -c "silentcast"
	cd -
fi

# End of file
